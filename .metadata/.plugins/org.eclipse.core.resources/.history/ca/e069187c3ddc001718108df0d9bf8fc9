package edu.sru.thangiah.zeus.metaheuristics.evolutionary.firefly;

import java.util.LinkedList;
import java.util.Random;
import java.util.Vector;

import edu.sru.thangiah.zeus.core.Settings;
import edu.sru.thangiah.zeus.metaheuristics.evolutionary.Chromosome;
import edu.sru.thangiah.zeus.metaheuristics.evolutionary.Configuration;
import edu.sru.thangiah.zeus.metaheuristics.evolutionary.IChromosome;
import edu.sru.thangiah.zeus.metaheuristics.evolutionary.IFitnessFunction;
import edu.sru.thangiah.zeus.metaheuristics.evolutionary.IGene;
import edu.sru.thangiah.zeus.metaheuristics.evolutionary.IGeneticOperator;
import edu.sru.thangiah.zeus.metaheuristics.evolutionary.IntegerGene;
import edu.sru.thangiah.zeus.metaheuristics.evolutionary.Population;
import edu.sru.thangiah.zeus.metaheuristics.evolutionary.RandomGenerator;

public class FireFlyOperator implements IGeneticOperator
{
	private Configuration configuration;
	private int crossoverCount;
	private Vector<Integer> nsLin = new Vector<Integer>();  // --> <--
	private Vector<Integer> nsRin = new Vector<Integer>();  // --> <--
	private Vector<Integer> nsLout = new Vector<Integer>(); // <-- -->
	private Vector<Integer> nsRout = new Vector<Integer>(); // <-- -->
	
	public FireFlyOperator(Configuration currentConfiguration)
	{
		configuration = currentConfiguration;
		crossoverCount = 0;
	}
	
	@Override
	public void operate(Population pop)
	{
		operate(pop, pop.getChromosomes());
	}

//==============================================================================================
//==============================================================================================	
//==============================================================================================
//==============================================================================================	
	
	
	@Override
	public void operate(Population ogPop, LinkedList<IChromosome> ogPopLL){
		Settings.printDebug(Settings.COMMENT, "Into Operator");
		IFitnessFunction fitFunc = configuration.getFitnessFunction();
		//double test = fitnessFunction.evaluate(ogPopLL.getLast());

		int totalGen = configuration.getNumGenerations();
		int totalPop = configuration.getPopulationSize();
		int tspSize = configuration.getChromosomeSize();
		Population newPop = new Population(configuration, ogPopLL);
		
		//System.out.println(totalGen + " " + totalPop + " " + tspSize);
		//System.out.println(newPop.calculateFittestChromosome().getTspCost());
		IChromosome currBright = newPop.getChromosomes().getFirst();
		findNewEdge(currBright, ogPopLL.getLast());
		
		for(int g=0; g<totalGen; g++) {
			//IChromosome currBright = newPop.getChromosome(0);
			for(int i=0; i<totalPop; i++) {
				//findNewEdge
				//xToy
				//ytoX
				//xFromy
				//yFromx
				
				
			}
		}
		
		
//-----------------------End Calculations---------------------------------
}
	
//==============================================================================================
//==============================================================================================
	
	
	
	private void findNewEdge(IChromosome brightFly, IChromosome randomFly) {
		Random rand = new Random();
		int firstPos = 999999999;
		int secondPos = 999999999;
		int tspMax = configuration.getChromosomeSize()-1;  //Max tsp size in chromosome LL (#node -1 for start at 0) 
		int keepRunning = 1;
		
		//Generates 2 connected random positions that do not exist in both lists
		while(keepRunning == 1) {
			firstPos = rand.nextInt(tspMax) + 0;
			int nextOrprev = rand.nextInt(1) + 0;	
			//1 is next and 0 is prev
			if(nextOrprev == 0 && firstPos !=0) {secondPos = firstPos-1;}
			else if(nextOrprev == 0 && firstPos == 0) {secondPos = firstPos+1;}
			else if(nextOrprev == 1 && firstPos != tspMax) {secondPos = firstPos+1;}
			else if(nextOrprev == 1 && firstPos == tspMax) {secondPos = firstPos-1;}
			else {System.out.println("Error occured pos gen in findNewEdge of Firefly");}
		
			int a1 = (int) brightFly.getGenes().get(firstPos).getInternalValue();
			int a2 = (int) brightFly.getGenes().get(secondPos).getInternalValue();
			int tempPos = randomFly.findGenePos(a1);
			int b1 = 999999999;
			int b2 = 999999999;
			try {
			b1 = (int) randomFly.getGenes().get(tempPos-1).getInternalValue();
			b2 = (int) randomFly.getGenes().get(tempPos+1).getInternalValue();
			} catch(Exception e) {};
			
			if(a2 != b1 && a2!= b2) {keepRunning=0;}
			System.out.println("still running");
			//Sets first pos to smaller one
			if(firstPos > secondPos) {
				int temp = firstPos;
				firstPos = secondPos;
				secondPos = temp;
			}
		}
		System.out.println("first is  " + firstPos + " second is  " + secondPos);
		
		
	}
	
	
	
	
	
	
	
	
	
	
	public Configuration getConfiguration(){ return configuration; }
}





